.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::Illrequest 3pm"
.TH Koha::Illrequest 3pm "2018-08-29" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Illrequest \- Koha Illrequest Object class
.SH "(Re)Design"
.IX Header "(Re)Design"
An ILLRequest consists of two parts; the Illrequest Koha::Object, and a series
of related Illrequestattributes.
.PP
The former encapsulates the basic necessary information that any \s-1ILL\s0 requires
to be usable in Koha.  The latter is a set of additional properties used by
one of the backends.
.PP
The former subsumes the legacy \*(L"Status\*(R" object.  The latter remains
encapsulated in the \*(L"Record\*(R" object.
.PP
\&\s-1TODO:\s0
.PP
\&\- Anything invoking the \->status method; annotated with:
  + # Old use of \->status !
.SH "API"
.IX Header "API"
.SS "Backend \s-1API\s0 Response Principles"
.IX Subsection "Backend API Response Principles"
All methods should return a hashref in the following format:
.IP "\(bu" 4
error
.Sp
This should be set to 1 if an error was encountered.
.IP "\(bu" 4
status
.Sp
The status should be a string from the list of statuses detailed below.
.IP "\(bu" 4
message
.Sp
The message is a free text field that can be passed on to the end user.
.IP "\(bu" 4
value
.Sp
The value returned by the method.
.SS "Interface Status Messages"
.IX Subsection "Interface Status Messages"
.IP "\(bu" 4
branch_address_incomplete
.Sp
An interface request has determined branch address details are incomplete.
.IP "\(bu" 4
cancel_success
.Sp
The interface's cancel_request method was successful in cancelling the
Illrequest using the \s-1API.\s0
.IP "\(bu" 4
cancel_fail
.Sp
The interface's cancel_request method failed to cancel the Illrequest using
the \s-1API.\s0
.IP "\(bu" 4
unavailable
.Sp
The interface's request method returned saying that the desired item is not
available for request.
.SS "Class methods"
.IX Subsection "Class methods"
\fIillrequestattributes\fR
.IX Subsection "illrequestattributes"
.PP
\fIpatron\fR
.IX Subsection "patron"
.PP
\fIload_backend\fR
.IX Subsection "load_backend"
.PP
Require \*(L"Base.pm\*(R" from the relevant \s-1ILL\s0 backend.
.PP
\fI_backend\fR
.IX Subsection "_backend"
.PP
.Vb 2
\&    my $backend = $abstract\->_backend($new_backend);
\&    my $backend = $abstract\->_backend;
.Ve
.PP
Getter/Setter for our \s-1API\s0 object.
.PP
\fI_backend_capability\fR
.IX Subsection "_backend_capability"
.PP
.Vb 1
\&    my $backend_capability_result = $self\->_backend_capability($name, $args);
.Ve
.PP
This is a helper method to invoke optional capabilities in the backend.  If
the capability named by \f(CW$name\fR is not supported, return 0, else invoke it,
passing \f(CW$args\fR along with the invocation, and return its return value.
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fI_config\fR
.IX Subsection "_config"
.PP
.Vb 2
\&    my $config = $abstract\->_config($config);
\&    my $config = $abstract\->_config;
.Ve
.PP
Getter/Setter for our config object.
.PP
\fImetadata\fR
.IX Subsection "metadata"
.PP
\fI_core_status_graph\fR
.IX Subsection "_core_status_graph"
.PP
.Vb 1
\&    my $core_status_graph = $illrequest\->_core_status_graph;
.Ve
.PP
Returns \s-1ILL\s0 module's default status graph.  A status graph defines the list of
available actions at any stage in the \s-1ILL\s0 workflow.  This is for instance used
by the perl script & template to generate the correct buttons to display to
the end user at any given point.
.PP
\fI_core_status_graph\fR
.IX Subsection "_core_status_graph"
.PP
.Vb 1
\&    my $status_graph = $illrequest\->_core_status_graph($origin, $new_graph);
.Ve
.PP
Return a new status_graph, the result of merging \f(CW$origin\fR & new_graph.  This is
operation is a union over the sets defied by the two graphs.
.PP
Each entry in \f(CW$new_graph\fR is added to \f(CW$origin\fR.  We do not provide a syntax for
\&'subtraction' of entries from \f(CW$origin\fR.
.PP
Whilst it is not intended that this works, you can override entries in \f(CW$origin\fR
with entries with the same key in \f(CW$new_graph\fR.  This can lead to problematic
behaviour when \f(CW$new_graph\fR adds an entry, which modifies a dependent entry in
\&\f(CW$origin\fR, only for the entry in \f(CW$origin\fR to be replaced later with a new entry
from \f(CW$new_graph\fR.
.PP
\&\s-1NOTE:\s0 this procedure does not \*(L"re-link\*(R" entries in \f(CW$origin\fR or \f(CW$new_graph\fR,
i.e. each of the graphs need to be correct at the outset of the operation.
.PP
\fIcapabilities\fR
.IX Subsection "capabilities"
.PP
.Vb 1
\&    my $capabilities = $illrequest\->capabilities;
.Ve
.PP
Return a hashref mapping methods to operation names supported by the queried
backend.
.PP
Example return value:
.PP
.Vb 1
\&    { create => "Create Request", confirm => "Progress Request" }
.Ve
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fIcustom_capability\fR
.IX Subsection "custom_capability"
.PP
Return the result of invoking \f(CW$CANDIDATE\fR on this request's backend with
\&\f(CW$PARAMS\fR, or 0 if \f(CW$CANDIDATE\fR is an unknown method on backend.
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fIavailable_backends\fR
.IX Subsection "available_backends"
.PP
Return a list of available backends.
.PP
\fIavailable_actions\fR
.IX Subsection "available_actions"
.PP
Return a list of available actions.
.PP
\fImark_completed\fR
.IX Subsection "mark_completed"
.PP
Mark a request as completed (status = \s-1COMP\s0).
.SS "backend_confirm"
.IX Subsection "backend_confirm"
Confirm a request. The backend handles setting of mandatory fields in the commit stage:
.IP "\(bu" 4
orderid
.IP "\(bu" 4
accessurl, cost (if available).
.PP
\fIbackend_update_status\fR
.IX Subsection "backend_update_status"
.PP
\fIbackend_cancel\fR
.IX Subsection "backend_cancel"
.PP
.Vb 1
\&    my $ILLResponse = $illRequest\->backend_cancel;
.Ve
.PP
The standard interface method allowing for request cancellation.
.PP
\fIbackend_renew\fR
.IX Subsection "backend_renew"
.PP
.Vb 1
\&    my $renew_response = $illRequest\->backend_renew;
.Ve
.PP
The standard interface method allowing for request renewal queries.
.PP
\fIbackend_create\fR
.IX Subsection "backend_create"
.PP
.Vb 1
\&    my $create_response = $abstractILL\->backend_create($params);
.Ve
.PP
Return an array of Record objects created by querying our backend with
a Search query.
.PP
In the context of the other \s-1ILL\s0 methods, this is a special method: we only
pass it \f(CW$params\fR, as it does not yet have any other data associated with it.
.PP
\fIexpandTemplate\fR
.IX Subsection "expandTemplate"
.PP
.Vb 1
\&    my $params = $abstract\->expandTemplate($params);
.Ve
.PP
Return a version of \f(CW$PARAMS\fR augmented with our required template path.
.PP
\fIgetLimits\fR
.IX Subsection "getLimits"
.PP
.Vb 4
\&    my $limit_rules = $abstract\->getLimits( {
\&        type  => \*(Aqbrw_cat\*(Aq | \*(Aqbranch\*(Aq,
\&        value => $value
\&    } );
.Ve
.PP
Return the \s-1ILL\s0 limit rules for the supplied combination of type / value.
.PP
As the config may have no rules for this particular type / value combination,
or for the default, we must define fall-back values here.
.PP
\fIgetPrefix\fR
.IX Subsection "getPrefix"
.PP
.Vb 4
\&    my $prefix = $abstract\->getPrefix( {
\&        brw_cat => $brw_cat,
\&        branch  => $branch_code,
\&    } );
.Ve
.PP
Return the \s-1ILL\s0 prefix as defined by our \f(CW$params:\fR either per borrower category,
per branch or the default.
.PP
\fIcheck_limits\fR
.IX Subsection "check_limits"
.PP
.Vb 4
\&    my $ok = $illRequests\->check_limits( {
\&        borrower   => $borrower,
\&        branchcode => \*(Aqbranchcode\*(Aq | undef,
\&    } );
.Ve
.PP
Given \f(CW$PARAMS\fR, a hashref containing a \f(CW$borrower\fR object and a \f(CW$branchcode\fR,
see whether we are still able to place ILLs.
.PP
LimitRules are derived from koha\-conf.xml:
 + default limit counts, and counting method
 + branch specific limit counts & counting method
 + borrower category specific limit counts & counting method
 + err on the side of caution: a counting fail will cause fail, even if
   the other counts passes.
.PP
\fIrequires_moderation\fR
.IX Subsection "requires_moderation"
.PP
.Vb 1
\&    my $status = $illRequest\->requires_moderation;
.Ve
.PP
Return the name of the status if moderation by staff is required; or 0
otherwise.
.PP
\fIgeneric_confirm\fR
.IX Subsection "generic_confirm"
.PP
.Vb 1
\&    my $stage_summary = $illRequest\->generic_confirm;
.Ve
.PP
Handle the generic_confirm extended method.  The first stage involves creating
a template email for the end user to edit in the browser.  The second stage
attempts to submit the email.
.PP
\fIid_prefix\fR
.IX Subsection "id_prefix"
.PP
.Vb 1
\&    my $prefix = $record\->id_prefix;
.Ve
.PP
Return the prefix appropriate for the current Illrequest as derived from the
borrower and branch associated with this request's Status, and the config
file.
.PP
\fI_censor\fR
.IX Subsection "_censor"
.PP
.Vb 1
\&    my $params = $illRequest\->_censor($params);
.Ve
.PP
Return \f(CW$params\fR, modified to reflect our censorship requirements.
.PP
\fI\s-1TO_JSON\s0\fR
.IX Subsection "TO_JSON"
.PP
.Vb 1
\&    $json = $illrequest\->TO_JSON
.Ve
.PP
Overloaded \fI\s-1TO_JSON\s0\fR method that takes care of inserting calculated values
into the unblessed representation of the object.
.SS "Internal methods"
.IX Subsection "Internal methods"
\fI_type\fR
.IX Subsection "_type"
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex Sassmannshausen <alex.sassmannshausen@ptfs\-europe.com>
