.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::SearchEngine::Elasticsearch 3pm"
.TH Koha::SearchEngine::Elasticsearch 3pm "2018-08-29" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::SearchEngine::Elasticsearch \- Base module for things using elasticsearch
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.IP "index" 4
.IX Item "index"
The name of the index to use, generally 'biblios' or 'authorities'.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "get_elasticsearch_params"
.IX Subsection "get_elasticsearch_params"
.Vb 1
\&    my $params = $self\->get_elasticsearch_params();
.Ve
.PP
This provides a hashref that contains the parameters for connecting to the
ElasicSearch servers, in the form:
.PP
.Vb 4
\&    {
\&        \*(Aqnodes\*(Aq => [\*(Aq127.0.0.1:9200\*(Aq, \*(Aqanotherserver:9200\*(Aq],
\&        \*(Aqindex_name\*(Aq => \*(Aqkoha_instance_index\*(Aq,
\&    }
.Ve
.PP
This is configured by the following in the \f(CW\*(C`config\*(C'\fR block in koha\-conf.xml:
.PP
.Vb 5
\&    <elasticsearch>
\&        <server>127.0.0.1:9200</server>
\&        <server>anotherserver:9200</server>
\&        <index_name>koha_instance</index_name>
\&    </elasticsearch>
.Ve
.SS "get_elasticsearch_settings"
.IX Subsection "get_elasticsearch_settings"
.Vb 1
\&    my $settings = $self\->get_elasticsearch_settings();
.Ve
.PP
This provides the settings provided to elasticsearch when an index is created.
These can do things like define tokenisation methods.
.PP
A hashref containing the settings is returned.
.SS "get_elasticsearch_mappings"
.IX Subsection "get_elasticsearch_mappings"
.Vb 1
\&    my $mappings = $self\->get_elasticsearch_mappings();
.Ve
.PP
This provides the mappings that get passed to elasticsearch when an index is
created.
.SS "_elasticsearch_mapping_for_*"
.IX Subsection "_elasticsearch_mapping_for_*"
Get the \s-1ES\s0 mappings for the given data type or a special mapping case
.PP
Receives the same parameters from the \f(CW$self\fR\->\fI_foreach_mapping()\fR dispatcher
.SS "_foreach_mapping"
.IX Subsection "_foreach_mapping"
.Vb 9
\&    $self\->_foreach_mapping(
\&        sub {
\&            my ( $name, $type, $facet, $suggestible, $sort, $marc_type,
\&                $marc_field )
\&              = @_;
\&            return unless $marc_type eq \*(Aqmarc21\*(Aq;
\&            print "Data comes from: " . $marc_field . "\en";
\&        }
\&    );
.Ve
.PP
This allows you to apply a function to each entry in the elasticsearch mappings
table, in order to build the mappings for whatever is needed.
.PP
In the provided function, the files are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The field name for elasticsearch (corresponds to the 'mapping' column in the
database.
.ie n .IP "$type" 4
.el .IP "\f(CW$type\fR" 4
.IX Item "$type"
The type for this value, e.g. 'string'.
.ie n .IP "$facet" 4
.el .IP "\f(CW$facet\fR" 4
.IX Item "$facet"
True if this value should be facetised. This only really makes sense if the
field is understood by the facet processing code anyway.
.ie n .IP "$sort" 4
.el .IP "\f(CW$sort\fR" 4
.IX Item "$sort"
True if this is a field that a) needs special sort handling, and b) if it
should be sorted on. False if a) but not b). Undef if not a). This allows,
for example, author to be sorted on but not everything marked with \*(L"author\*(R"
to be included in that sort.
.ie n .IP "$marc_type" 4
.el .IP "\f(CW$marc_type\fR" 4
.IX Item "$marc_type"
A string that indicates the \s-1MARC\s0 type that this mapping is for, e.g. 'marc21',
\&'unimarc', 'normarc'.
.ie n .IP "$marc_field" 4
.el .IP "\f(CW$marc_field\fR" 4
.IX Item "$marc_field"
A string that describes the \s-1MARC\s0 field that contains the data to extract.
These are of a form suited to Catmandu's \s-1MARC\s0 fixers.
.SS "process_error"
.IX Subsection "process_error"
.Vb 1
\&    die process_error($@);
.Ve
.PP
This parses an Elasticsearch error message and produces a human-readable
result from it. This result is probably missing all the useful information
that you might want in diagnosing an issue, so the warning is also logged.
.PP
Note that currently the resulting message is not internationalised. This
will happen eventually by some method or other.
.SS "_read_configuration"
.IX Subsection "_read_configuration"
.Vb 1
\&    my $conf = _read_configuration();
.Ve
.PP
Reads the \fIconfiguration file\fR and returns a hash structure with the
configuration information. It raises an exception if mandatory entries
are missing.
.PP
The hashref structure has the following form:
.PP
.Vb 4
\&    {
\&        \*(Aqnodes\*(Aq => [\*(Aq127.0.0.1:9200\*(Aq, \*(Aqanotherserver:9200\*(Aq],
\&        \*(Aqindex_name\*(Aq => \*(Aqkoha_instance\*(Aq,
\&    }
.Ve
.PP
This is configured by the following in the \f(CW\*(C`config\*(C'\fR block in koha\-conf.xml:
.PP
.Vb 5
\&    <elasticsearch>
\&        <server>127.0.0.1:9200</server>
\&        <server>anotherserver:9200</server>
\&        <index_name>koha_instance</index_name>
\&    </elasticsearch>
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.ie n .IP "Chris Cormack ""<chrisc@catalyst.net.nz>""" 4
.el .IP "Chris Cormack \f(CW<chrisc@catalyst.net.nz>\fR" 4
.IX Item "Chris Cormack <chrisc@catalyst.net.nz>"
.PD 0
.ie n .IP "Robin Sheat ""<robin@catalyst.net.nz>""" 4
.el .IP "Robin Sheat \f(CW<robin@catalyst.net.nz>\fR" 4
.IX Item "Robin Sheat <robin@catalyst.net.nz>"
.ie n .IP "Jonathan Druart ""<jonathan.druart@bugs.koha\-community.org>""" 4
.el .IP "Jonathan Druart \f(CW<jonathan.druart@bugs.koha\-community.org>\fR" 4
.IX Item "Jonathan Druart <jonathan.druart@bugs.koha-community.org>"
