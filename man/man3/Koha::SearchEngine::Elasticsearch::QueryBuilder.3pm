.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::SearchEngine::Elasticsearch::QueryBuilder 3pm"
.TH Koha::SearchEngine::Elasticsearch::QueryBuilder 3pm "2018-08-29" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::SearchEngine::Elasticsearch::QueryBuilder \- constructs elasticsearch
query objects from user\-supplied queries
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides the functions that take a user-supplied search query, and
provides something that can be given to elasticsearch to get answers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Koha::SearchEngine::Elasticsearch::QueryBuilder;
\&    $builder = Koha::SearchEngine::Elasticsearch\->new({ index => $index });
\&    my $simple_query = $builder\->build_query("hello");
\&    # This is currently undocumented because the original code is undocumented
\&    my $adv_query = $builder\->build_advanced_query($indexes, $operands, $operators);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "build_query"
.IX Subsection "build_query"
.Vb 1
\&    my $simple_query = $builder\->build_query("hello", %options)
.Ve
.PP
This will build a query that can be issued to elasticsearch from the provided
string input. This expects a lucene style search form (see
<http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query\-dsl\-query\-string\-query.html#query\-string\-syntax>
for details.)
.PP
It'll make an attempt to respect the various query options.
.PP
Additional options can be provided with the \f(CW%options\fR hash.
.IP "sort" 4
.IX Item "sort"
This should be an arrayref of hashrefs, each containing a \f(CW\*(C`field\*(C'\fR and an
\&\f(CW\*(C`direction\*(C'\fR (optional, defaults to \f(CW\*(C`asc\*(C'\fR.) The results will be sorted
according to these values. Valid values for \f(CW\*(C`direction\*(C'\fR are 'asc' and 'desc'.
.SS "build_browse_query"
.IX Subsection "build_browse_query"
.Vb 1
\&    my $browse_query = $builder\->build_browse_query($field, $query);
.Ve
.PP
This performs a \*(L"starts with\*(R" style query on a particular field. The field
to be searched must have been indexed with an appropriate mapping as a
\&\*(L"phrase\*(R" subfield, which pretty much everything has.
.SS "build_query_compat"
.IX Subsection "build_query_compat"
.Vb 7
\&    my (
\&        $error,             $query, $simple_query, $query_cgi,
\&        $query_desc,        $limit, $limit_cgi,    $limit_desc,
\&        $stopwords_removed, $query_type
\&      )
\&      = $builder\->build_query_compat( \e@operators, \e@operands, \e@indexes,
\&        \e@limits, \e@sort_by, $scan, $lang );
.Ve
.PP
This handles a search using the same api as C4::Search::buildQuery does.
.PP
A very simple query will go in with \f(CW$operands\fR set to ['query'], and
\&\f(CW$sort_by\fR set to ['pubdate_dsc']. This simple case will return with
\&\f(CW$query\fR set to something that can perform the search, \f(CW$simple_query\fR
set to just the search term, \f(CW$query_cgi\fR set to something that can
reproduce this search, and \f(CW$query_desc\fR set to something else.
.SS "build_authorities_query"
.IX Subsection "build_authorities_query"
.Vb 1
\&    my $query = $builder\->build_authorities_query(\e%search);
.Ve
.PP
This takes a nice description of an authority search and turns it into a black-box
query that can then be passed to the appropriate searcher.
.PP
The search description is a hashref that looks something like:
.PP
.Vb 10
\&    {
\&        searches => [
\&            {
\&                where    => \*(AqHeading\*(Aq,    # search the main entry
\&                operator => \*(Aqexact\*(Aq,        # require an exact match
\&                value    => \*(Aqfrogs\*(Aq,        # the search string
\&            },
\&            {
\&                where    => \*(Aq\*(Aq,             # search all entries
\&                operator => \*(Aq\*(Aq,             # default keyword, right truncation
\&                value    => \*(Aqpond\*(Aq,
\&            },
\&        ],
\&        sort => {
\&            field => \*(AqHeading\*(Aq,
\&            order => \*(Aqdesc\*(Aq,
\&        },
\&        authtypecode => \*(AqTOPIC_TERM\*(Aq,
\&    }
.Ve
.SS "build_authorities_query_compat"
.IX Subsection "build_authorities_query_compat"
.Vb 3
\&    my ($query) =
\&      $builder\->build_authorities_query_compat( \e@marclist, \e@and_or,
\&        \e@excluding, \e@operator, \e@value, $authtypecode, $orderby );
.Ve
.PP
This builds a query for searching for authorities, in the style of
C4::AuthoritiesMarc::SearchAuthorities.
.PP
Arguments:
.IP "marclist" 4
.IX Item "marclist"
An arrayref containing where the particular term should be searched for.
Options are: mainmainentry, mainentry, match, match-heading, see-from, and
thesaurus. If left blank, any field is used.
.IP "and_or" 4
.IX Item "and_or"
Totally ignored. It is never used in C4::AuthoritiesMarc::SearchAuthorities.
.IP "excluding" 4
.IX Item "excluding"
Also ignored.
.IP "operator" 4
.IX Item "operator"
What form of search to do. Options are: is (phrase, no trunction, whole field
must match), = (number exact match), exact (phrase, but with left and right
truncation). If left blank, then word list, right truncted, anywhere is used.
.IP "value" 4
.IX Item "value"
The actual user-provided string value to search for.
.IP "authtypecode" 4
.IX Item "authtypecode"
The authority type code to search within. If blank, then all will be searched.
.IP "orderby" 4
.IX Item "orderby"
The order to sort the results by. Options are Relevance, HeadingAsc,
HeadingDsc, AuthidAsc, AuthidDsc.
.PP
marclist, operator, and value must be the same length, and the values at
index /i/ all relate to each other.
.PP
This returns a query, which is a black box object that can be passed to the
appropriate search object.
.SS "_convert_sort_fields"
.IX Subsection "_convert_sort_fields"
.Vb 1
\&    my @sort_params = _convert_sort_fields(@sort_by)
.Ve
.PP
Converts the zebra-style sort index information into elasticsearch-style.
.PP
\&\f(CW@sort_by\fR is the same as presented to build_query_compat, and it returns
something that can be sent to build_query.
.SS "_convert_index_fields"
.IX Subsection "_convert_index_fields"
.Vb 1
\&    my @index_params = $self\->_convert_index_fields(@indexes);
.Ve
.PP
Converts zebra-style search index notation into elasticsearch-style.
.PP
\&\f(CW@indexes\fR is an array of index names, as presented to build_query_compat,
and it returns something that can be sent to build_query.
.PP
\&\fB\s-1TODO\s0\fR: this will pull from the elasticsearch mappings table to figure out
types.
.SS "_convert_index_strings"
.IX Subsection "_convert_index_strings"
.Vb 1
\&    my @searches = $self\->_convert_index_strings(@searches);
.Ve
.PP
Similar to _convert_index_fields, this takes strings of the form
\&\fBfield:search term\fR and rewrites the field from zebra-style to
elasticsearch-style. Anything it doesn't understand is returned verbatim.
.SS "_convert_index_strings_freeform"
.IX Subsection "_convert_index_strings_freeform"
.Vb 1
\&    my $search = $self\->_convert_index_strings_freeform($search);
.Ve
.PP
This is similar to _convert_index_strings, however it'll search out the
things to change within the string. So it can handle strings such as
\&\f(CW\*(C`(su:foo) AND (su:bar)\*(C'\fR, converting the \f(CW\*(C`su\*(C'\fR appropriately.
.PP
If there is something of the form \*(L"su,complete\-subfield\*(R" or something, the
second part is stripped off as we can't yet handle that. Making it work
will have to wait for a real query parser.
.SS "_modify_string_by_type"
.IX Subsection "_modify_string_by_type"
.Vb 1
\&    my $str = $self\->_modify_string_by_type(%index_field);
.Ve
.PP
If you have a search term (operand) and a type (phrase, right-truncated), this
will convert the string to have the function in lucene search terms, e.g.
wrapping quotes around it.
.SS "_join_queries"
.IX Subsection "_join_queries"
.Vb 1
\&    my $query_str = $self\->_join_queries(@query_parts);
.Ve
.PP
This takes a list of query parts, that might be search terms on their own, or
booleaned together, or specifying fields, or whatever, wraps them in
parentheses, and ANDs them all together. Suitable for feeding to the \s-1ES\s0
query string query.
.PP
Note: doesn't \s-1AND\s0 them together if they specify an index that starts with \*(L"mc\*(R"
as that was a special case in the original code for dealing with multiple
choice options (you can't search for something that has an itype of A and
and itype of B otherwise.)
.SS "_make_phrases"
.IX Subsection "_make_phrases"
.Vb 1
\&    my @phrased_queries = $self\->_make_phrases(@query_parts);
.Ve
.PP
This takes the supplied queries and forces them to be phrases by wrapping
quotes around them. It understands field prefixes, e.g. 'subject:' and puts
the quotes outside of them if they're there.
.SS "_create_query_string"
.IX Subsection "_create_query_string"
.Vb 1
\&    my @query_strings = $self\->_create_query_string(@queries);
.Ve
.PP
Given a list of hashrefs, it will turn them into a lucene-style query string.
The hash should contain field, type (both for the indexes), operator, and
operand.
.SS "_clean_search_term"
.IX Subsection "_clean_search_term"
.Vb 1
\&    my $term = $self\->_clean_search_term($term);
.Ve
.PP
This cleans a search term by removing any funny characters that may upset
\&\s-1ES\s0 and give us an error. It also calls _convert_index_strings_freeform
to ensure those parts are correct.
.SS "_fix_limit_special_cases"
.IX Subsection "_fix_limit_special_cases"
.Vb 1
\&    my $limits = $self\->_fix_limit_special_cases($limits);
.Ve
.PP
This converts any special cases that the limit specifications have into things
that are more readily processable by the rest of the code.
.PP
The argument should be an arrayref, and it'll return an arrayref.
.SS "_sort_field"
.IX Subsection "_sort_field"
.Vb 1
\&    my $field = $self\->_sort_field($field);
.Ve
.PP
Given a field name, this works out what the actual name of the version to sort
on should be. Often it's the same, sometimes it involves sticking \*(L"_\|_sort\*(R" on
the end. Maybe it'll be something else in the future, who knows?
.SS "_truncate_terms"
.IX Subsection "_truncate_terms"
.Vb 1
\&    my $query = $self\->_truncate_terms($query);
.Ve
.PP
Given a string query this function appends '*' wildcard  to all terms except
operands and double quoted strings.
