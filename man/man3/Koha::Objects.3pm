.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::Objects 3pm"
.TH Koha::Objects 3pm "2018-08-29" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Objects \- Koha Object set base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Koha::Objects;
\&    my @objects = Koha::Objects\->search({ borrowernumber => $borrowernumber});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class must be subclassed.
.SH "API"
.IX Header "API"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fIKoha::Objects\->\fInew()\fI;\fR
.IX Subsection "Koha::Objects->new();"
.PP
my \f(CW$object\fR = Koha::Objects\->\fInew()\fR;
.PP
\fIKoha::Objects\->\fI_new_from_dbic()\fI;\fR
.IX Subsection "Koha::Objects->_new_from_dbic();"
.PP
my \f(CW$object\fR = Koha::Objects\->_new_from_dbic( \f(CW$resultset\fR );
.PP
\fIKoha::Objects\->\fIfind()\fI;\fR
.IX Subsection "Koha::Objects->find();"
.PP
Similar to DBIx::Class::ResultSet\->find this method accepts:
    \e%columns_values | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?
Strictly speaking, columns_values should only refer to columns under an
unique constraint.
.PP
my \f(CW$object\fR = Koha::Objects\->find( { col1 => \f(CW$val1\fR, col2 => \f(CW$val2\fR } );
my \f(CW$object\fR = Koha::Objects\->find( \f(CW$id\fR );
my \f(CW$object\fR = Koha::Objects\->find( \f(CW$idpart1\fR, \f(CW$idpart2\fR, \f(CW$attrs\fR ); # composite \s-1PK\s0
.PP
\fIKoha::Objects\->\fIfind_or_create()\fI;\fR
.IX Subsection "Koha::Objects->find_or_create();"
.PP
my \f(CW$object\fR = Koha::Objects\->find_or_create( \f(CW$attrs\fR );
.PP
\fIKoha::Objects\->\fIsearch()\fI;\fR
.IX Subsection "Koha::Objects->search();"
.PP
my \f(CW@objects\fR = Koha::Objects\->search($params);
.PP
\fIsearch_related\fR
.IX Subsection "search_related"
.PP
.Vb 2
\&    my @objects = Koha::Objects\->search_related( $rel_name, $cond?, \e%attrs? );
\&    my $objects = Koha::Objects\->search_related( $rel_name, $cond?, \e%attrs? );
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and attributes for matching records.
.PP
\fIsingle\fR
.IX Subsection "single"
.PP
my \f(CW$object\fR = Koha::Objects\->search({}, { rows => 1 })\->single
.PP
Returns one and only one object that is part of this set.
Returns undef if there are no objects found.
.PP
This is optimal as it will grab the first returned result without instantiating
a cursor.
.PP
See:
http://search.cpan.org/dist/DBIx\-Class/lib/DBIx/Class/Manual/Cookbook.pod#Retrieve_one_and_only_one_row_from_a_resultset
.PP
\fIKoha::Objects\->\fInext()\fI;\fR
.IX Subsection "Koha::Objects->next();"
.PP
my \f(CW$object\fR = Koha::Objects\->\fInext()\fR;
.PP
Returns the next object that is part of this set.
Returns undef if there are no more objects to return.
.PP
\fIKoha::Objects\->last;\fR
.IX Subsection "Koha::Objects->last;"
.PP
my \f(CW$object\fR = Koha::Objects\->last;
.PP
Returns the last object that is part of this set.
Returns undef if there are no object to return.
.PP
\fIKoha::Objects\->\fIreset()\fI;\fR
.IX Subsection "Koha::Objects->reset();"
.PP
Koha::Objects\->\fIreset()\fR;
.PP
resets iteration so the next call to \fInext()\fR will start agein
with the first object in a set.
.PP
\fIKoha::Objects\->\fIas_list()\fI;\fR
.IX Subsection "Koha::Objects->as_list();"
.PP
Koha::Objects\->\fIas_list()\fR;
.PP
Returns an arrayref of the objects in this set.
.PP
\fIKoha::Objects\->unblessed\fR
.IX Subsection "Koha::Objects->unblessed"
.PP
Returns an unblessed representation of objects.
.PP
\fIKoha::Objects\->get_column\fR
.IX Subsection "Koha::Objects->get_column"
.PP
Return all the values of this set for a given column
.PP
\fIKoha::Objects\->\s-1TO_JSON\s0\fR
.IX Subsection "Koha::Objects->TO_JSON"
.PP
Returns an unblessed representation of objects, suitable for \s-1JSON\s0 output.
.PP
\fIKoha::Objects\->_wrap\fR
.IX Subsection "Koha::Objects->_wrap"
.PP
wraps the \s-1DBIC\s0 object in a corresponding Koha object
.PP
\fIKoha::Objects\->_resultset\fR
.IX Subsection "Koha::Objects->_resultset"
.PP
Returns the internal resultset or creates it if undefined
.PP
\fIcolumns\fR
.IX Subsection "columns"
.PP
my \f(CW@columns\fR = Koha::Objects\->columns
.PP
Return the table columns
.PP
\fI\s-1AUTOLOAD\s0\fR
.IX Subsection "AUTOLOAD"
.PP
The autoload method is used call DBIx::Class method on a resultset.
.PP
Important: If you plan to use one of the DBIx::Class methods you must provide
relevant tests in t/db_dependent/Koha/Objects.t
Currently count, pager, update and delete are covered.
.PP
\fI_type\fR
.IX Subsection "_type"
.PP
The _type method must be set for all child classes.
The value returned by it should be the \s-1DBIC\s0 resultset name.
For example, for holds, _type should return 'Reserve'.
.PP
\fIobject_class\fR
.IX Subsection "object_class"
.PP
This method must be set for all child classes.
The value returned by it should be the name of the Koha
object class that is returned by this class.
For example, for holds, object_class should return 'Koha::Hold'.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kyle M Hall <kyle@bywatersolutions.com>
