.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::Patron 3pm"
.TH Koha::Patron 3pm "2018-08-29" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Patron \- Koha Patron Object class
.SH "API"
.IX Header "API"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fIdelete\fR
.IX Subsection "delete"
.PP
\&\f(CW$patron\fR\->delete
.PP
Delete patron's holds, lists and finally the patron.
.PP
Lists owned by the borrower are deleted, but entries from the borrower to
other lists are kept.
.PP
\fIcategory\fR
.IX Subsection "category"
.PP
my \f(CW$patron_category\fR = \f(CW$patron\fR\->category
.PP
Return the patron category for this patron
.PP
\fIguarantor\fR
.IX Subsection "guarantor"
.PP
Returns a Koha::Patron object for this patron's guarantor
.PP
\fIguarantees\fR
.IX Subsection "guarantees"
.PP
Returns the guarantees (list of Koha::Patron) of this patron
.PP
\fIhousebound_profile\fR
.IX Subsection "housebound_profile"
.PP
Returns the HouseboundProfile associated with this patron.
.PP
\fIhousebound_role\fR
.IX Subsection "housebound_role"
.PP
Returns the HouseboundRole associated with this patron.
.PP
\fIsiblings\fR
.IX Subsection "siblings"
.PP
Returns the siblings of this patron.
.PP
\fImerge_with\fR
.IX Subsection "merge_with"
.PP
.Vb 2
\&    my $patron = Koha::Patrons\->find($id);
\&    $patron\->merge_with( \e@patron_ids );
\&
\&    This subroutine merges a list of patrons into the patron record. This is accomplished by finding
\&    all related patron ids for the patrons to be merged in other tables and changing the ids to be that
\&    of the keeper patron.
.Ve
.PP
\fIwants_check_for_previous_checkout\fR
.IX Subsection "wants_check_for_previous_checkout"
.PP
.Vb 1
\&    $wants_check = $patron\->wants_check_for_previous_checkout;
.Ve
.PP
Return 1 if Koha needs to perform PrevIssue checking, else 0.
.PP
\fIdo_check_for_previous_checkout\fR
.IX Subsection "do_check_for_previous_checkout"
.PP
.Vb 1
\&    $do_check = $patron\->do_check_for_previous_checkout($item);
.Ve
.PP
Return 1 if the bib associated with \f(CW$ITEM\fR has previously been checked out to
\&\f(CW$PATRON\fR, 0 otherwise.
.PP
\fIis_debarred\fR
.IX Subsection "is_debarred"
.PP
my \f(CW$debarment_expiration\fR = \f(CW$patron\fR\->is_debarred;
.PP
Returns the date a patron debarment will expire, or undef if the patron is not
debarred
.PP
\fIis_expired\fR
.IX Subsection "is_expired"
.PP
my \f(CW$is_expired\fR = \f(CW$patron\fR\->is_expired;
.PP
Returns 1 if the patron is expired or 0;
.PP
\fIis_going_to_expire\fR
.IX Subsection "is_going_to_expire"
.PP
my \f(CW$is_going_to_expire\fR = \f(CW$patron\fR\->is_going_to_expire;
.PP
Returns 1 if the patron is going to expired, depending on the NotifyBorrowerDeparture pref or 0
.PP
\fIupdate_password\fR
.IX Subsection "update_password"
.PP
my \f(CW$updated\fR = \f(CW$patron\fR\->update_password( \f(CW$userid\fR, \f(CW$password\fR );
.PP
Update the userid and the password of a patron.
If the userid already exists, returns and let DBIx::Class warns
This will add an entry to action_logs if BorrowersLog is set.
.PP
\fIrenew_account\fR
.IX Subsection "renew_account"
.PP
my \f(CW$new_expiry_date\fR = \f(CW$patron\fR\->renew_account
.PP
Extending the subscription to the expiry date.
.PP
\fIhas_overdues\fR
.IX Subsection "has_overdues"
.PP
my \f(CW$has_overdues\fR = \f(CW$patron\fR\->has_overdues;
.PP
Returns the number of patron's overdues
.PP
\fItrack_login\fR
.IX Subsection "track_login"
.PP
.Vb 2
\&    $patron\->track_login;
\&    $patron\->track_login({ force => 1 });
\&
\&    Tracks a (successful) login attempt.
\&    The preference TrackLastPatronActivity must be enabled. Or you
\&    should pass the force parameter.
.Ve
.PP
\fImove_to_deleted\fR
.IX Subsection "move_to_deleted"
.PP
my \f(CW$is_moved\fR = \f(CW$patron\fR\->move_to_deleted;
.PP
Move a patron to the deletedborrowers table.
This can be done before deleting a patron, to make sure the data are not completely deleted.
.PP
\fIarticle_requests\fR
.IX Subsection "article_requests"
.PP
my \f(CW@requests\fR = \f(CW$borrower\fR\->\fIarticle_requests()\fR;
my \f(CW$requests\fR = \f(CW$borrower\fR\->\fIarticle_requests()\fR;
.PP
Returns either a list of ArticleRequests objects,
or an ArtitleRequests object, depending on the
calling context.
.PP
\fIarticle_requests_current\fR
.IX Subsection "article_requests_current"
.PP
my \f(CW@requests\fR = \f(CW$patron\fR\->article_requests_current
.PP
Returns the article requests associated with this patron that are incomplete
.PP
\fIarticle_requests_finished\fR
.IX Subsection "article_requests_finished"
.PP
my \f(CW@requests\fR = \f(CW$biblio\fR\->article_requests_finished
.PP
Returns the article requests associated with this patron that are completed
.PP
\fIadd_enrolment_fee_if_needed\fR
.IX Subsection "add_enrolment_fee_if_needed"
.PP
my \f(CW$enrolment_fee\fR = \f(CW$patron\fR\->add_enrolment_fee_if_needed;
.PP
Add enrolment fee for a patron if needed.
.PP
\fIcheckouts\fR
.IX Subsection "checkouts"
.PP
my \f(CW$checkouts\fR = \f(CW$patron\fR\->checkouts
.PP
\fIpending_checkouts\fR
.IX Subsection "pending_checkouts"
.PP
my \f(CW$pending_checkouts\fR = \f(CW$patron\fR\->pending_checkouts
.PP
This method will return the same as \f(CW$self\fR\->checkouts, but with a prefetch on
items, biblio and biblioitems.
.PP
It has been introduced to replaced the C4::Members::GetPendingIssues subroutine
.PP
It should not be used directly, prefer to access fields you need instead of
retrieving all these fields in one go.
.PP
\fIold_checkouts\fR
.IX Subsection "old_checkouts"
.PP
my \f(CW$old_checkouts\fR = \f(CW$patron\fR\->old_checkouts
.PP
\fIget_overdues\fR
.IX Subsection "get_overdues"
.PP
my \f(CW$overdue_items\fR = \f(CW$patron\fR\->get_overdues
.PP
Return the overdue items
.PP
\fIget_routing_lists\fR
.IX Subsection "get_routing_lists"
.PP
my \f(CW@routinglists\fR = \f(CW$patron\fR\->get_routing_lists
.PP
Returns the routing lists a patron is subscribed to.
.PP
\fIget_age\fR
.IX Subsection "get_age"
.PP
my \f(CW$age\fR = \f(CW$patron\fR\->get_age
.PP
Return the age of the patron
.PP
\fIaccount\fR
.IX Subsection "account"
.PP
my \f(CW$account\fR = \f(CW$patron\fR\->account
.PP
\fIholds\fR
.IX Subsection "holds"
.PP
my \f(CW$holds\fR = \f(CW$patron\fR\->holds
.PP
Return all the holds placed by this patron
.PP
\fIold_holds\fR
.IX Subsection "old_holds"
.PP
my \f(CW$old_holds\fR = \f(CW$patron\fR\->old_holds
.PP
Return all the historical holds for this patron
.PP
\fInotice_email_address\fR
.IX Subsection "notice_email_address"
.PP
.Vb 1
\&  my $email = $patron\->notice_email_address;
.Ve
.PP
Return the email address of patron used for notices.
Returns the empty string if no email address.
.PP
\fIfirst_valid_email_address\fR
.IX Subsection "first_valid_email_address"
.PP
my \f(CW$first_valid_email_address\fR = \f(CW$patron\fR\->first_valid_email_address
.PP
Return the first valid email address for a patron.
For now, the order  is defined as email, emailpro, B_email.
Returns the empty string if the borrower has no email addresses.
.PP
\fIget_club_enrollments\fR
.IX Subsection "get_club_enrollments"
.PP
\fIget_enrollable_clubs\fR
.IX Subsection "get_enrollable_clubs"
.PP
\fIaccount_locked\fR
.IX Subsection "account_locked"
.PP
my \f(CW$is_locked\fR = \f(CW$patron\fR\->account_locked
.PP
Return true if the patron has reach the maximum number of login attempts (see pref FailedLoginAttempts).
Otherwise return false.
If the pref is not set (empty string, null or 0), the feature is considered as disabled.
.PP
\fIcan_see_patron_infos\fR
.IX Subsection "can_see_patron_infos"
.PP
my \f(CW$can_see\fR = \f(CW$patron\fR\->can_see_patron_infos( \f(CW$patron\fR );
.PP
Return true if the patron (usually the logged in user) can see the patron's infos for a given patron
.PP
\fIcan_see_patrons_from\fR
.IX Subsection "can_see_patrons_from"
.PP
my \f(CW$can_see\fR = \f(CW$patron\fR\->can_see_patrons_from( \f(CW$branchcode\fR );
.PP
Return true if the patron (usually the logged in user) can see the patron's infos from a given library
.PP
\fIlibraries_where_can_see_patrons\fR
.IX Subsection "libraries_where_can_see_patrons"
.PP
my \f(CW$libraries\fR = \f(CW$patron\fR\-libraries_where_can_see_patrons;
.PP
Return the list of branchcodes(!) of libraries the patron is allowed to see other patron's infos.
The branchcodes are arbitrarily returned sorted.
We are supposing here that the object is related to the logged in patron (use of C4::Context::only_my_library)
.PP
An empty array means no restriction, the patron can see patron's infos from any libraries.
.PP
\fIis_adult\fR
.IX Subsection "is_adult"
.PP
my \f(CW$is_adult\fR = \f(CW$patron\fR\->is_adult
.PP
Return true if the patron has a category with a type Adult (A) or Organization (I)
.PP
\fIis_child\fR
.IX Subsection "is_child"
.PP
my \f(CW$is_child\fR = \f(CW$patron\fR\->is_child
.PP
Return true if the patron has a category with a type Child (C)
.PP
\fIhas_valid_userid\fR
.IX Subsection "has_valid_userid"
.PP
my \f(CW$patron\fR = Koha::Patrons\->find(42);
\&\f(CW$patron\fR\->userid( \f(CW$new_userid\fR );
my \f(CW$has_a_valid_userid\fR = \f(CW$patron\fR\->has_valid_userid
.PP
my \f(CW$patron\fR = Koha::Patron\->new( \f(CW$params\fR );
my \f(CW$has_a_valid_userid\fR = \f(CW$patron\fR\->has_valid_userid
.PP
Return true if the current userid of this patron is valid/unique, otherwise false.
.PP
Note that this should be done in \f(CW$self\fR\->store instead and raise an exception if needed.
.PP
\fIgenerate_userid\fR
.IX Subsection "generate_userid"
.PP
my \f(CW$patron\fR = Koha::Patron\->new( \f(CW$params\fR );
my \f(CW$userid\fR = \f(CW$patron\fR\->generate_userid
.PP
Generate a userid using the \f(CW$surname\fR and the \f(CW$firstname\fR (if there is a value in \f(CW$firstname\fR).
.PP
Return the generate userid ($firstname.$surname if there is a \f(CW$firstname\fR, or \f(CW$surname\fR if there is no value in \f(CW$firstname\fR) plus offset (0 if the \f(CW$userid\fR is unique, or a higher numeric value if not unique).
.PP
# Note: Should we set \f(CW$self\fR\->userid with the generated value?
# Certainly yes, but we AddMember and ModMember will be rewritten
.SS "Internal methods"
.IX Subsection "Internal methods"
\fI_type\fR
.IX Subsection "_type"
.SH "AUTHOR"
.IX Header "AUTHOR"
Kyle M Hall <kyle@bywatersolutions.com>
Alex Sassmannshausen <alex.sassmannshausen@ptfs\-europe.com>
